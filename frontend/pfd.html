<!DOCTYPE html>
<html>
    <head>
        <title>PFD</title>
        <style>
            body { background: black; margin: 0; font-family: 'Roboto', sans-serif; user-select: none; }
            canvas { display: block; margin: auto; background: black; }
            
        </style>
        <div id="errorBox" style="
            display: none;
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: black;
            border: 2px solid red;
            color: white;
            padding: 10px 20px;
            font-family: monospace, sans-serif, 'Segoe UI', Tahoma, Geneva, Verdana, Oxygen, 'Tw Cen MT', 'ISOCP', 'TechnicBold';
            font-size: 16px;
            z-index: 1000;
            white-space: nowrap;
            user-select: none;
            ">
        </div>

        
    </head>
    <body>
        <canvas id="pfd" width="600" height="570"></canvas>
        <script>
            // This is the new pfd.js
            let canvas = document.getElementById('pfd');
            let ctx = canvas.getContext('2d');

            let horizonImg = new Image();
            horizonImg.src = 'artificial_horizon.png';
            let attitudeImg = new Image();
            attitudeImg.src = 'attitude_indicator.png';

            // --- Flight Data Variables ---
            // These will be updated by the WebSocket
            let pitch = 0, bank = 0, airspeed = 282, mach = 0.85, altitude = 25000, heading = 0, verticalSpeed = 0;
            let selectedAltitude = 25000, selectedAirspeed = 0, qnh = 1013;

            
            const config = {
                skyColor: '#0087FF',
                groundColor: '#A55200',
                fdColor: '#00FF00', // Flight Director color
                aircraftSymbolColor: '#D4AC0D', // Yellow/gold
            };
            
            
            // --- WebSocket Connection ---
            let ws = new WebSocket("ws://127.0.0.1:8080/pfd");
            ws.onmessage = (msg) => {
                let data = JSON.parse(msg.data);
                if (data.error) {
                    errorBox.textContent = data.message;
                    errorBox.style.display = 'block';
                    return;
                }

                errorBox.style.display = 'none'; // Hide error box if no error

                pitch = data.pitch;
                bank = data.bank;
                airspeed = data.airspeed;
                mach = data.mach;
                altitude = data.altitude;
                heading = data.heading;
                verticalSpeed = data.verticalSpeed;
                selectedAltitude = data.selectedAltitude;
                selectedAirspeed = data.selectedAirspeed;
                selectedMach = data.selectedMach;
                qnh = data.qnh;

            };
            ws.onerror = (err) => {
                console.error("WebSocket Error:", err);
            };
            ws.onclose = () => {
                console.log("WebSocket connection closed.");
            };

            

            function drawRoundedRect(ctx, x, y, width, height, rectRadius) {
                ctx.beginPath();
                ctx.moveTo(x + rectRadius, y);
                ctx.lineTo(x + width - rectRadius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + rectRadius);
                ctx.lineTo(x + width, y + height - rectRadius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - rectRadius, y + height);
                ctx.lineTo(x + rectRadius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - rectRadius);
                ctx.lineTo(x, y + rectRadius);
                ctx.quadraticCurveTo(x, y, x + rectRadius, y);
                ctx.closePath();
            }

            function drawArtificialHorizon() {
                ctx.save();

                const maskWidth = 900
                const maskHeight = maskWidth * (10/16);
                maskX = (canvas.width - maskWidth) / 2;
                maskY = (canvas.height - maskHeight) / 2;

                ctx.beginPath();
                ctx.rect(maskX, maskY, maskWidth, maskHeight);
                ctx.clip();

                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate(bank * Math.PI / 180);
                const pitchOffset = pitch * 8.77; // 10 pixels per degree of pitch

                ctx.drawImage(horizonImg, -horizonImg.width / 2, -horizonImg.height / 2 - pitchOffset);

                ctx.restore();
            }

            function drawFixedSymbols() {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);

                let scale = 0.1;
                let newWidth = attitudeImg.width * scale;
                let newHeight = attitudeImg.height * scale;

                ctx.drawImage(attitudeImg, -newWidth / 2, (-newHeight / 2) + 10, newWidth, newHeight);

                ctx.restore();
            }

            function drawRollScale() {
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2;
                const radius = 200;
                const angles = [-60, -45, -30, -20, -10, 10, 20, 30, 45, 60];
                angles.forEach(angle => {
                    const rad = angle * Math.PI / 180;
                    const tickLength = (angle % 30 === 0 || Math.abs(angle) === 45) ? 15 : 10;
                    let x1 = Math.sin(rad) * radius;
                    let y1 = -Math.cos(rad) * radius;
                    let x2 = Math.sin(rad) * (radius + tickLength);
                    let y2 = -Math.cos(rad) * (radius + tickLength);
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x2, y2);
                    ctx.stroke();
                });

                // Bank Angle Pointer
                ctx.rotate(bank * Math.PI / 180);
                ctx.fillStyle = config.aircraftSymbolColor;
                ctx.beginPath();
                ctx.moveTo(0, -radius - 2);
                ctx.lineTo(-10, -radius - 17);
                ctx.lineTo(10, -radius - 17);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }           

            // --- IMPROVED SPEED TAPE VARIABLES ---
            let prevSpeed = 0;
            let speedTrend = 0;
            let projectedSpeed = 0;
            let smoothedAirspeed = 0; // Add smoothed airspeed for display only

            // Constants - these are fixed values
            const SPEED_RESOLUTION = 1; // Round to nearest knot
            const TREND_DEADBAND = 1.5; // Minimum change to show trend
            const DISPLAY_RESPONSE_TIME = 1.5; // Slower for display smoothing
            const TREND_RESPONSE_TIME = 0.8; // Faster for trend calculation - more responsive
            const SPEED_TREND_PROJECTION_SECONDS = 6.0;

            let prevAltitude = 0;
            let altitudeTrend = 0;
            let projectedAltitude = 0;
            let smoothedAltitude = 0;

            const ALTITUDE_RESOLUTION = 10;
            const ALTITUDE_TREND_PROJECTION_SECONDS = 6.0;

            let lastUpdateTime = null;

            function updateSpeedTrend(rawAirspeed, deltaTime) {
                // Use faster smoothing for trend calculation to be more responsive
                const trendSmoothingFactor = 1 - Math.exp(-deltaTime / TREND_RESPONSE_TIME);
                // Use slower smoothing for display to reduce jitter
                const displaySmoothingFactor = 1 - Math.exp(-deltaTime / DISPLAY_RESPONSE_TIME);
                
                // Initialize smoothed airspeed on first run
                if (smoothedAirspeed === 0) smoothedAirspeed = rawAirspeed;
                
                // Calculate trend based on RAW airspeed for responsiveness
                let rawTrend = (rawAirspeed - prevSpeed) / deltaTime;
                speedTrend += trendSmoothingFactor * (rawTrend - speedTrend);
                
                // Project based on RAW airspeed, not smoothed
                projectedSpeed = rawAirspeed + (speedTrend * SPEED_TREND_PROJECTION_SECONDS);
                
                // Smooth airspeed separately for display purposes only
                smoothedAirspeed += displaySmoothingFactor * (rawAirspeed - smoothedAirspeed);
                
                prevSpeed = rawAirspeed; // Use raw airspeed for next trend calculation
            }

            function updateAltitudeTrend(rawAltitude, deltaTime) {
                const trendSmoothingFactor = 1 - Math.exp(-deltaTime / TREND_RESPONSE_TIME);
                const displaySmoothingFactor = 1 - Math.exp(-deltaTime / DISPLAY_RESPONSE_TIME);

                if (smoothedAltitude === 0) smoothedAltitude = rawAltitude;
                let rawTrend = (rawAltitude - prevAltitude) / deltaTime;
                altitudeTrend += trendSmoothingFactor * (rawTrend - altitudeTrend);
                projectedAltitude = rawAltitude + (altitudeTrend * ALTITUDE_TREND_PROJECTION_SECONDS);
                smoothedAltitude += displaySmoothingFactor * (rawAltitude - smoothedAltitude);
                prevAltitude = rawAltitude;
            }

            function drawSpeedTape() { // All the smart shit like trend calculation is vibe coded, because i was lazy
                const x = 50, y = 155, width = 65, height = 260;
                const centerY = y + height / 2;
                const pxPerKnot = 4;
                const now = performance.now() / 1000;
                
                if (lastUpdateTime != null) {
                    const deltaTime = now - lastUpdateTime;
                    if (prevSpeed !== null && deltaTime > 0) {
                        updateSpeedTrend(airspeed, deltaTime); // Pass raw airspeed
                    }
                } else {
                    // Initialize on first run
                    smoothedAirspeed = airspeed;
                    prevSpeed = airspeed;
                }
                lastUpdateTime = now;
            
                ctx.save();
                ctx.beginPath();
                ctx.rect(x, y, width, height);
                ctx.clip();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(x, y, width, height);
                ctx.strokeStyle = "white"; 
                ctx.fillStyle = "white"; 
                ctx.font = "18px 'Tw Cen MT'"; 
                ctx.textAlign = "right";
                
                // Use smoothed airspeed for tape positioning and display
                const startSpeed = Math.floor(smoothedAirspeed / 10) * 10 - 50;
                for (let speed = startSpeed; speed <= startSpeed + 100; speed += 10) {
                    if (speed < 0) continue;
                    const yPos = centerY - (speed - smoothedAirspeed) * pxPerKnot;
                    ctx.beginPath();
                    ctx.moveTo(x + width - 20, yPos);
                    ctx.lineTo(x + width, yPos);
                    ctx.stroke();
                    ctx.fillText(speed.toString(), x + width - 25, yPos + 6);
                }
                ctx.restore();
            
                // Current Speed Indicator
                ctx.strokeStyle = "white";
                ctx.strokeRect(x, y, width, height);
                
                // Draw inner rounded rectangle (black fill)
                drawRoundedRect(ctx, x, centerY - 18, width, 36, 5);
                ctx.fillStyle = 'black';
                ctx.strokeStyle = "white";
                ctx.fill();
                ctx.stroke();
                
                // Speed resolution rounding (use smoothed for display)
                const displayedSpeed = Math.round(smoothedAirspeed / SPEED_RESOLUTION) * SPEED_RESOLUTION;
                
                // Draw text with rounded speed
                ctx.fillStyle = 'white';
                ctx.font = "bold 22px 'Tw Cen MT'";
                ctx.textAlign = "center";
                ctx.fillText(displayedSpeed, x + width / 2, centerY + 8);
                
                // Trend deadband - Use RAW airspeed for trend calculation to be responsive
                const trendDifference = Math.abs(projectedSpeed - airspeed);
                const trendY = centerY - (projectedSpeed - smoothedAirspeed) * pxPerKnot; // But position relative to smoothed display
                
                if (trendDifference >= TREND_DEADBAND) {
                    ctx.strokeStyle = "magenta";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + width / 2, centerY);    // start at current speed
                    ctx.lineTo(x + width / 2, trendY);     // end at projected speed
                    ctx.stroke();
                    
                    // Add arrow head for better visibility
                    const arrowSize = 6;
                    const direction = trendY < centerY ? -1 : 1;
                    ctx.beginPath();
                    ctx.moveTo(x + width / 2, trendY);
                    ctx.lineTo(x + width / 2 - arrowSize/2, trendY - direction * arrowSize);
                    ctx.lineTo(x + width / 2 + arrowSize/2, trendY - direction * arrowSize);
                    ctx.closePath();
                    ctx.fillStyle = "magenta";
                    ctx.fill();
                }

                ctx.fillStyle = "cyan"; ctx.font = "bold 20px 'Tw Cen MT'"; ctx.textAlign = "center";
                ctx.fillText(Math.round(selectedAirspeed), x + width/2, y-8);
                
                // Mach indicator
                let machText = "";
                if (mach >= 0.4) {
                    machText = mach;
                }
                else {
                    machText = ""
                }
                ctx.fillStyle = "white"; ctx.font = "16px 'Tw Cen MT'";
                ctx.fillText(machText, x + width/2, y + height + 20);
                
                // Reset line width
                ctx.lineWidth = 1;
            }   

            function drawAltitudeTape() {
                const x = canvas.width - 115, y = 155, width = 80, height = 260;
                const centerY = y + height / 2;
                const pxPer100ft = 20;
                const now = performance.now() / 1000;

                if (lastUpdateTime != null) {
                    const deltaTime = now - lastUpdateTime;
                    if (prevAltitude !== null && deltaTime > 0) {
                        updateAltitudeTrend(altitude, deltaTime);
                    }
                } else {
                    smoothedAltitude = altitude;
                    prevAltitude = altitude;
                }
                lastUpdateTime = now;

                ctx.save();
                ctx.beginPath(); ctx.rect(x, y, width, height); ctx.clip();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)'; ctx.fillRect(x, y, width, height);
                
                ctx.strokeStyle = "white"; ctx.fillStyle = "white"; ctx.font = "18px 'Tw Cen MT'"; ctx.textAlign = "left";
                
                const startAlt = Math.floor(altitude / 100) * 100 - 1000;
                for (let alt = startAlt; alt <= startAlt + 2000; alt += 100) {
                    const yPos = centerY - ((alt - altitude) / 100) * pxPer100ft;
                    ctx.beginPath(); ctx.moveTo(x, yPos); ctx.lineTo(x + 20, yPos); ctx.stroke();
                    ctx.fillText((alt / 100).toFixed(0).padStart(3, '0'), x + 25, yPos + 6);
                }
                ctx.restore();
                
                // Current Altitude Indicator
                ctx.strokeStyle = "white"; ctx.strokeRect(x, y, width, height);
                
                //Current Altitude Indicator real
                drawRoundedRect(ctx, x, centerY - 18, width, 36, 5);
                ctx.fillStyle = "black";
                ctx.strokeStyle = "white";
                ctx.fill();
                ctx.stroke();
                
                ctx.fillStyle = "white";
                ctx.font = "bold 22px 'Tw Cen MT'";
                ctx.textAlign = "center";
                ctx.fillText(Math.round(altitude), x + width / 2, centerY + 8);

                // Selected Altitude
                ctx.fillStyle = "cyan"; ctx.font = "bold 20px 'Tw Cen MT'"; ctx.textAlign = "center";
                ctx.fillText(Math.round(selectedAltitude), x + width/2, y-8);

                // QNH Setting
                ctx.fillStyle = "white"; ctx.font = "16px 'Tw Cen MT'";
                ctx.fillText("QNH " + Math.round(qnh), x + width/2, y + height + 20);

                const TREND_DIFFERENCE = Math.abs(projectedAltitude - altitude);
                const TREND_Y = centerY - (projectedAltitude - smoothedAltitude) * pxPer100ft;

                if (TREND_DIFFERENCE >= TREND_DEADBAND) {
                    ctx.strokeStyle = "magenta";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x + width / 2, centerY);
                    ctx.lineTo(x + width / 2, TREND_Y);

                    const arrowSize = 6;
                    const direction = TREND_Y < centerY ? -1 : 1;
                    ctx.beginPath();
                    ctx.moveTo(x + width / 2, TREND_Y);
                    ctx.lineTo(x + width / 2 - arrowSize/2, TREND_Y - direction * arrowSize);
                    ctx.lineTo(x + width / 2 + arrowSize/2, TREND_Y - direction * arrowSize);
                    ctx.closePath();
                    ctx.fillStyle = "magenta";
                    ctx.fill();
                }

                ctx.lineWidth = 1;
            }

            function drawHeadingTape() {
                const x = canvas.width/2 - 150, y = canvas.height - 45, width = 300, height = 40;
                const centerX = x + width/2, pxPerDeg = 5;

                ctx.save();
                ctx.beginPath(); ctx.rect(x, y, width, height); ctx.clip();
                ctx.fillStyle = 'rgba(0,0,0,0.5)'; ctx.fillRect(x, y, width, height);
                ctx.strokeStyle = "white"; ctx.fillStyle = "white"; ctx.font = "16px 'Tw Cen MT'"; ctx.textAlign = "center";
                
                const startHdg = Math.round(heading - 35);
                for (let h = startHdg; h <= startHdg + 70; h++) {
                    let h_norm = (h + 360) % 360;
                    const xPos = centerX + (h - heading) * pxPerDeg;
                    if (h_norm % 10 === 0) {
                        ctx.beginPath(); ctx.moveTo(xPos, y); ctx.lineTo(xPos, y + 15); ctx.stroke();
                        let text = (h_norm/10).toString().padStart(2, '0');
                        ctx.fillText(text, xPos, y + 35);
                    } else if (h_norm % 5 === 0) {
                        ctx.beginPath(); ctx.moveTo(xPos, y); ctx.lineTo(xPos, y + 10); ctx.stroke();
                    }
                }
                ctx.restore();

                // Center indicator
                ctx.strokeStyle = "white"; ctx.strokeRect(x, y, width, height);
                ctx.fillStyle = "white"; ctx.font = "bold 18px 'Tw Cen MT'";
                ctx.strokeRect(centerX - 30, y-1, 60, 22);
                ctx.fillRect(centerX - 30, y-1, 60, 22);
                ctx.fillStyle = 'black';
                ctx.fillText(Math.round(heading).toString().padStart(3,'0'), centerX, y + 16);
            }

            function drawVSIndicator() {
                const x = canvas.width - 25, y = 120, height = 260;
                const centerY = y + height / 2, maxVS = 3000;
                const pxPer100fpm = (height / 2) / (maxVS / 100) / 100;

                ctx.strokeStyle = "white"; ctx.fillStyle = "white"; ctx.font = "14px 'Tw Cen MT'"; ctx.textAlign = "left";
                
                // Draw scale
                [-2000, -1000, 1000, 2000].forEach(val => {
                    const yPos = centerY - val * pxPer100fpm;
                    ctx.beginPath(); ctx.moveTo(x, yPos); ctx.lineTo(x - 10, yPos); ctx.stroke();
                    ctx.fillText((Math.abs(val)/1000).toFixed(0), x - 20, yPos + 5);
                });
                
                // Draw needle
                if(Math.abs(verticalSpeed) > 100) {
                    const vsClamped = Math.max(-maxVS, Math.min(maxVS, verticalSpeed));
                    const needleY = centerY - vsClamped * pxPer100fpm;
                    ctx.strokeStyle = config.fdColor;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x, centerY);
                    ctx.lineTo(x, needleY);
                    ctx.lineTo(x - 10, needleY);
                    ctx.stroke();
                }
            }
            
            function drawFMA() {
                ctx.textAlign = "center";
                ctx.fillStyle = "#1F1F1F";
                ctx.fillRect(0, 0, canvas.width, 65); // Distance to rest of PFD is 70, height has 5 px of margin
                const topY = 20;
                const fma = [
                    {text: 'SPEED', color: 'lime', x: 80}, {text: 'G/S', color: 'lime', x: 190},
                    {text: 'LOC', color: 'lime', x: 270}, {text: 'CAT3\nDUAL', color: 'white', x: 380},
                    {text: 'AP1+2\nFD 2\nA/THR', color: 'white', x: 490},
                ];
                const fmaItems = [
                    {id: 'fmaSpeed', text: 'SPEED', color: 'lime', x: canvas.width / 3},
                ];
                fma.forEach(item => {
                    ctx.fillStyle = item.color;
                    ctx.font = `bold ${item.text.includes('\n') ? '16px' : '25px'} Tw Cen MT`;
                    let lines = item.text.split('\n');
                    lines.forEach((line, index) => ctx.fillText(line, item.x, topY + index * 18));
                });
            }
            
            // --- Main Draw Loop ---
            function draw() {
                ctx.fillStyle = 'black';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                drawArtificialHorizon();
                drawRollScale();
                drawFixedSymbols(); // Drawn on top of horizon but below tapes
                drawSpeedTape();
                drawAltitudeTape();
                drawHeadingTape();
                drawVSIndicator();
                drawFMA();

                requestAnimationFrame(draw);
            }
            draw();

            // --- Error Handling ---
            let errorBox = document.getElementById('errorBox');
        </script>
    </body>
</html>